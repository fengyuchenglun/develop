

​	刚开始学习接触企业代码的时候，一定会发现，工程中充斥着各种`XO`：DO、VO、DTO、DAO，还有各种名词：POJO，JavaBean，Domain等等，这些貌似看起来都一样，又好像用在不同的地方 ；常见的软件应用分层架构,各种XO是如何在各层定义以及流转,大家都是比较迷糊。

在这里结合自己的理解对做些介绍。 



### 1. 应用分层

 我们在软件开发设计及开发过程中，习惯将软件横向拆分为几个层。比如常见的三层架构：表现层(UI)/业务逻辑层(BAL)/数据访问层(DAL)。 

![image-20200814111602982](https://i.loli.net/2020/08/14/tQTryADoI7GCJXU.png)

那应用系统为什么要分层呢？

其实主要是解决一下几个问题：

- 解耦
  有一句计算机名言
  软件的所有问题都可以通过增加一层来解决。
  当系统越大，团队越多，需求变化越快时，越需要保证程序之间的依赖关系越少。而分层/面向接口编程，会使我们在应对变化时越容易。
- 简化问题
  当我们想不明白从用户操作一直到数据落盘整个过程的交互情况时，我们应该换种方式思考。想想各层应该提供哪些支持，通过对各层分工的明确定义，复杂问题就变成了如何将各层功能组合起来的“积木搭建”。
- 降低系统维护与升级成本
  这里体现了面向接口编程的优势。我们抽象出数据访问层后，只需要保证对外提供的接口不变，底层数据库使用Oracle还是MySql，上层结构是感知不到的。
- 逻辑复用/代码复用
  通过分层，明确定义各层职责，再也不会出现系统中多个地方查询同一个数据库表的代码。因为查询某个数据库表的工作只会由一个数据访问层类来统一提供。
- 提高团队开发效率
  如果开发团队很多，通过分层和接口定义。各团队只需要遵循接口标准/开发规范，就可以并行开发。

**一个比较形象的比喻：分层化相当于把软件横向切几刀，模块化相当于把软件纵向切几刀。**

在《阿里巴巴Java开发手册》中，对应用分层的建议是这样的：

![image-20200814111627434](https://i.loli.net/2020/08/14/GXKpyF42B9PjOql.png)

- 开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制/流量控制等。

- 终端显示层：各个端的模版渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。

- Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。

- Service层：相对具体的业务逻辑服务层。

- Manager层：通用业务处理层，它有如下特征：

- - 对第三方平台封装的层，预处理返回结果及转化异常信息。
  - 对Service层通用能力的下沉，如缓存方案/中间件通用处理。
  - 与DAO层交互，对多个DAO的组合复用。

- DAO层：数据访问层，与底层MySQL、Oracle、HBase等进行数据交互。

- 外部接口或第三方平台：包括其他部门RPC开放接口，基础平台，其他公司的HTTP接口。

以上的层级只是在原来三层架构的基础上进行了细分，而这些细分的层级仅仅是为了满足业务的需要。千万不要为了分层而分层。过多的层会增加系统的复杂度和开发难度。

应用被细分为多个层次，每个层关注的点不同。所以在这基础上，抽象出不同的领域模型。也就是我们常见的DTO，DO等等。

其本质的目的还是为了达到分层解耦的效果。



### 2. 分层领域模型

在介绍分层领域模型之前我们介绍与之相关的基本概念。

 **POJO** 

Plain Ordinary Java Object 的缩写，表示一个简单 java 对象。 就是一个我们最常见的普通Java对象，这个概念是被大家叫出来的，它具有一些属性，然后提供对应的getter和setter 。

上面说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。 

 **JavaBean**

`JavaBean，可序列化的POJO`，sun在早期有对其规范（[JavaBeans Spec](https://link.zhihu.com/?target=https%3A//www.oracle.com/technetwork/java/javase/documentation/spec-136004.html)），它是Java中的可重用组件，主要规范约定如下：

1、所有的属性都被 private修饰

2、这个类必须有一个无参构造器

3、所有的属性必须都提供 get…()&set…() 方法

4、这个类必须是可序列化的，实现 serializable 接口

JavaBean已经成为Java的一种规范，也是Java社区的共同语言，许多工具框架也是遵循JavaBean的规范的，例如，Spring的BeanUtils，一些Json工具都是基于JavaBean的规范来实现的，这些都是基于约定，所以也有人把JavaBean叫为可以持久化的POJO。

 **Entity**

 entity的意思就是实体的意思，所以也是最常用到的，entity包中的类是必须和数据库相对应的 。

 **Model**

 模型的意思，当用model当包名的时候，一般里面存的是实体类的模型，一般是用来给前端用的。一般用于前端显示以及参数校验。

 **Domain**

域的意思，跟javabean一样， 表示宽泛的模型的意思 。

> 实践：entity、model、domain主要用于包命名。



 《阿里开发手册》提供的分层领域模型规约参考 

- DO(Data Object)

  此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。

  > 这里还有一个PO，**PO 是** Persistant Object 的缩写，用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。PO与DO意思基本相同，可不做特别区别。

- DTO(Data Transfer Object)

  数据传输对象，Service或Manager向外传输的对象。

- BO(Business Object)

  业务对象，由Service层输出的封装业务逻辑的对象。

- AO(Application Object)

  应用对象，在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

> 在通常的分层结构以及一般的系统中 ，DTO、BO、AO都可以归成DTO，不做具体区分；

- VO(View Object)

  显示层对象，通常是Web向模版渲染引擎层传输的对象。

- Query：

  数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。

> 数据查询对象可以分成两种：
>
> 1. XXXQuery：用于过滤条件封装。
>
>    比如：用户列表查询接口。页面根据用户昵称、用户名、用户状态、用户创建时间、用户性别等。
>
>    我们可以封装成UserQuery。
>
> 2. XXXForm：用户表单提交参数封装。
>
>    比如: 创建/修改用户，需要页面表单提交用户昵称、用户名、用户性别、用户邮箱、手机号码等信息。
>
>    我们可以封装成UserForm。

![](K:\@project-dianli@\notebook\培训\XSx7QyDHth4ONpj.png)

分层领域模型的在各层流转结构图大概是这样：

![image-20200814111702105](https://i.loli.net/2020/08/14/7GEvy1QnouNjfJ2.png)

​	在给出的参考中并没有对模型对象进行非常明确的划分，特别是对BO、AO、DTO的界限不是非常明确。这也是因为系统处理的业务不同、复杂度不同导致的。所以在设计系统分层和建模的时候，需要综合考虑实际应用场景。



### 3. 分层领域模型为什么重要

可能有些小伙伴会觉得麻烦，为什么要弄出这么多O？转来转去的多累！

使用分层领域模型的优点主要有以下几点：

1. 减小网络流量,减少不必要字段传输。
   比如查看博客列表，页面只需要展示博客标题，时间，作者等内容，博客内容是不需要返回的；

   此处可以定义一个只包含博客标题、时间、作者，不包含博客内容的BlogVO，很方便的处理展示的内容。
   
2. 保证返回数据安全，防止数据库表结构泄露。
    比如查看用户详情接口，数据库用户表中有用户名、密码、性别、手机号码、手机邮箱等字段。后端查看用户详情接口如果返回密码，这是不安全的。

  此处可以定义一个不包含密码的UserDetailVO，防止密码传输到前端。

3. 方便进行入参校验
    比如使用hibernate validator对前台传过来的请求参数就行参数验证！保证了入参的有效性，减少了重复代码。

4. 方便某些字段转换

   比如政治面貌字段，我们在数据库中可能存储的是数字，但是在前端页面我要展示的是中文描述。这种情况下前端可以通过`if/else`的方式来分情况展示。但是如果又增加了一个政治状态，前端需要与后台沟通修改代码。 

  此处可以定义一个UserVO包含 political ,politicalName。political政治面貌的数值表示，politicalName的中文描述。

5. 提高代码可读性以及可维护性，各层只关注自己感兴趣的内容

   通过VO、DTO、VO中封装各层输入输出参数或者结果，在类或者类属性字段上添加注释，比起通过Map作为入参出参的方式，能够清晰的了解入参出参的数量以及各字段的具体含义。



​	虽然分层领域模型有如此多的优点，但是他会导致“类臃肿”，类数量可能成倍增长,各层之间模型需要转来转去。但是这样是值得的。不同模型之间转来转去的确实头疼，我们现在可能更需要关注各模型之间的互相转换。



分层领域模型转换工具

那就让我们来梳理一下，在模型转换时都需要注意哪些问题～～

在进行不同领域对象转换时，有些问题是需要我们考虑的。

![](https://pic2.zhimg.com/80/v2-55f4b252ce902f8ea06217cd9418f46d_hd.jpg)

1. 原对象和目标对象相同属性的类型不一样，有的是Date，有的是BigDecimal，还有的是枚举
2. 属性的名称也不一样
3. 集合类属性中的泛型也不一样
4. 能不能只复制一部分属性
5. 能不能自定义转换逻辑
6. 嵌套对象是深拷贝还是浅拷贝

这么多需要考虑的地方，咱们要怎么处理，才能优雅的进行模型转换呢？

常见的模型转换方法了解下！

1. 最简单粗暴的方法，直接通过Set/Get方式来进行人肉赋值

2. FastJson

3. Spring封装BeanUtils工具类

5. cglib工具包BeanCopier

6. MapStruct框架


| 工具/框架              | 自定义转换逻辑 | 性能 | 说明                                                         |
| ---------------------- | -------------- | ---- | ------------------------------------------------------------ |
| 人肉赋值set/get        | 是             | 极高 | 1. 直观，简单，处理速度快<br>2. 属性过多的时候，人容易崩溃   |
| FastJson               | 否             | 一般 | 1. 使用方便。<br>2. 利用序列化反序列，性能一般<br>3. 不支持不同属性名的复制 |
| Spring BeanUtils工具类 | 否             | 高   | 1. 使用反射原理<br>2. 不支持不同类型、不同属性名的复制       |
| cglib BeanCopier       | 是             | 很高 | 1. 使用字节码技术，性能很高<br>2. 使用复杂                   |
| MapStruct              | 是             | 高   | 1. 编译时自动生成接口实现类<br>2.性能等于人工赋值<br>3.使用方便，简单,功能强大<br>4.需要添加额外的类 |

介绍的这些转换方法中，在性能上基本遵循：手动赋值 > 字节码生成 > 动态代理 > 反射。

性能排行榜:人肉赋值set/get>MapStruct>BeanCopier>BeanUtils>FastJson

在实际项目中，需要综合使用上述方法进行模型转换。比如较低层的DO，因为涉及到的嵌套对象少，结构简单，所以可以使用BeanUtils直接转。如果两个模型映射逻辑复杂、嵌套逻辑多且对速度要求很高，可以优先使用MapStruct；如果是速度、稳定优先的系统并且模型属性值不多，可以直接使用Set、Get实现。



### 4. 分层领域模型编写规范

下面我们看一下根据《阿里巴巴Java开发手册》，我们编写javabean以及分层领域模型需要注意的地方:

1. 【强制】 类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO
   / PO / UID 等。
   正例： JavaServerlessPlatform / UserDO / XmlService / TcpUdpDeal / TaPromotion
   反例： javaserverlessplatform / UserDo / XMLService / TCPUDPDeal / TAPromotion  
2. 【强制】 POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。
   说明： 在本文 MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在
   <resultMap>设置从 is_xxx 到 xxx 的映射关系。
   反例： 定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()， RPC 框架在反向解析的时候， “误以为” 对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。  
3.   【推荐】 领域模型命名规约
   1） 数据对象： xxxDO， xxx 即为数据表名。
   2） 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。
   3） 展示对象： xxxVO， xxx 一般为网页名称。
   4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO  
4.   【强制】 定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。
   正例： 数据库字段的 bigint 必须与类属性的 Long 类型相对应。
   反例： 某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来越大，超过 Integer 的表示范围而溢出成为负数。  
5.   关于基本数据类型与包装数据类型的使用标准如下：
   1） 【强制】 所有的 POJO 类属性必须使用包装数据类型。
   2） 【强制】 RPC 方法的返回值和参数必须使用包装数据类型。
   3） 【推荐】 所有的局部变量使用基本数据类型。
   说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。
   正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。
   反例： 比如显示成交总额涨跌情况，即正负 x%， x 为基本数据类型，调用的 RPC 服务，调用不成功时， 返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。  
6.   【强制】 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。
   反例： POJO 类的 createTime 默认值为 new Date()， 但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。
7.   【强制】 序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果
   完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。
   说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常  
8.   【强制】 POJO 类必须写 toString 方法。使用 IDE 中的工具： source> generate toString
   时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。
   说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。  
9.   【强制】 禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx()和 getXxx()方法。
   说明： 框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到。    





### 5. 参考资料

1.  http://www.blogjava.net/johnnylzb/archive/2010/05/15/321057.html 
2.  http://php-note.com/article/1666.html 
3.  https://time.geekbang.org/column/article/138331 
4.  https://blog.51cto.com/zero01/2441196 
5.   https://www.jianshu.com/p/1a0586d106ee 
6.   https://zhuanlan.zhihu.com/p/86282401 
7.   https://zhuanlan.zhihu.com/p/58928241 